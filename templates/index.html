<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>DETECTING MALARIA</title>
    <!-- <link href="https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js"></script>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
      -->
    <link rel="stylesheet" href="../static/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/css/jquery.bxslider.min.css">
    <link rel="stylesheet" href="../static/css/index.css">
</head>

<body>

    <header>
        <div class="logo-bkdn">
            <img src="../static/img/Logo_dhbkdn.jpg" alt="Logo_bkdn" width="100" height="100">
            <span class="name-bkdn">TRƯỜNG ĐẠI HỌC BÁCH KHOA ĐÀ NẴNG</span>
        </div>
        <div class="logo-dtvt text-center">
            <img src="../static/img/logo_dtvt.jpg" alt="Logo_dtvt" width="95" height="95">
            <span class="name-dtvt">KHOA ĐIỆN TỬ VIỄN THÔNG</span>
        </div>
            
    </header>

    <nav class="navbar navbar-expand-sm bg-secondary navbar-dark">
        <div class="container">
            <a class="navbar-brand" href="#">DETECTING MALARIA</a>
            <button class="btn btn-dark " type="button">Liên hệ </button>
        </div>
    </nav>
    <!-- vd -->
    <div class="container">
        <div class="text-center">
            <h2>PHÁT HIỆN BỆNH SỐT RÉT</h2>
        </div>
          
        <div class="introduct">
            <h3>Giới thiệu</h3>
            <div class="opening row">
            <div class="col-sm-10">
                <p>Bệnh sốt rét <i>(malaria)</i> là một bệnh truyền nhiễm do muỗi truyền, thường lây lan bởi muỗi Anophen <i>(Anopheles)</i> .
                    Bệnh gây ra bởi kí sinh trùng Plasmodium, lây truyền từ người này sang người khác khi những người này bị muỗi đốt.
                    Vết cắn của muỗi đưa ký sinh trùng từ nước bọt vào máu người. Ký sinh trùng di chuyển đến gan nơi chúng trưởng thành và sinh sản.
                    Bệnh phổ biến ở các vùng nhiệt đới và cận nhiệt đới tồn tại trong một dải rộng xung quanh xích đạo. 
                    Phổ biến phần lớn Châu Phi, Châu Á và Mĩ Latinh.
                    Mỗi năm có khoảng 200 triệu trường hợp nhiễm bệnh và khoảng 500.000 ca tử vong. Điều đó ảnh hưởng tiêu cực đến phát triển kinh tế và ước tính sẽ gây thiệt hại 12 tỷ USD mỗi năm.
                </p>
            </div>
            <div class="col-sm-2 text-center">
                <img src="../static/img/anopheles.jpeg" alt="anopheles" width="170px">
                <a  target="_blank" href="https://en.wikipedia.org/wiki/Anopheles">Muỗi Anophen </a>
            </div>
            <div class="row ">
                <div class="col-sm-2"></div>
                <div class="col-sm-10">
                <ul class="slider">
                    <li><img src="../static/img/khu-vuc.png" alt="khu-vuc" width="750px" height="550px"></li>
                    <li><img src="../static/img/ty-le-khu-vuc.png" alt="ty-le-khu-vuc" width="750px" height="550px"></li>
                    <li><img src="../static/img/chau-phi.png" alt="chau-phi"  width="750px" height="550px">></li>
                    <li><img src="../static/img/chau-my.png" alt="chau-my" width="750px" height="550px"></li>
                    <li><img src="../static/img/chau-a.png" alt="chau-a" width="750px" height="550px"></li>
                    <li><img src="../static/img/thai-binh-duong.png" alt="thai-binh-duong" width="750px" height="550px"></li>
                </ul>
                </div>
                <div class="col-sm-12 text-center">
                <p class="name-img">
                    Bản đồ thế giới về các khu vực hiện đang bị ảnh bơi bệnh sốt rét
                    <a target="_blank" href="https://www.treated.com/malaria/world-map-risk">(nguồn)</a>
                </p></div>
            </div>
            </div>
        
            <div class="trieu-chung">
            <h4>Dấu hiệu và triệu chứng</h4>
            <div class="row">
                <div class="col-sm-4">
                    <ul>
                        <li>Ớn lạnh từ vừa đến nặng</li>
                        <li>Sốt cao</li>
                        <li>Toát mồ hôi </li>
                        <li>Đau đầu </li>
                        <li>Nôn mửa, buồn nôn</li>
                        <li>Tiêu chảy</li>
                        <li>Thiếu máu</li>
                        <li>Đau cơ</li>
                        <li>Co giật</li>
                        <li>Hôn mê</li>
                        <li>Phân lẫn máu</li>
                    </ul>
                </div>
                <div class="col-sm-8 text-center">
                <img src="../static/img/trieu-chung.png" alt="trieu-chung" width="300px" height="280px">
                <p class="name-img">Triệu chứng của bệnh sốt rét</p>
                </div>
            </div>
            </div>
            
            <div class="chan-doan">
            <h4>Chẩn đoán</h4>
            <p>
                Kiểm tra bằng kính hiển vi là phương pháp biết đến nhiều nhất để chẩn đoán bệnh sốt rét.
                Máu của bệnh nhân được bôi trên một phiến kính và nhuộm màu bằng chất tương phản tạo điều kiện cho việc xác định ký sinh trùng trong các tế bào hồng cầu.
                Một bác sĩ lâm sàng được đào tạo sẽ kiểm tra từng mẫu dưới kính hiển vi và đếm các tế bào hồng cầu có chứa ký sinh trùng
            </p>
            <div class="text-center"> 
                <img src="../static/img/chan-doan.png" alt="chan-doan" width="500px">
                <p class="name-img">Chẩn đoán bệnh sốt rét</p>
            </div>
            <p>
                Theo giao thức đếm ký sinh trùng sốt rét chính thức của WHO,
                một bác sĩ lâm sàng có thể phải đếm thủ công lên tới 5.000 tế bào
                <a target="_blank" href="http://www.wpro.who.int/mvp/lab_quality/2096_oms_gmp_sop_09_rev1.pdf">(nguồn)</a>
                Đây là một quá trình cực kỳ tẻ nhạt và tốn thời gian. Gây gánh nặng phòng khám, đặc biệt là khi dịch bệnh xảy ra.
                Do đó, việc áp dụng phân tích hình ảnh và học máy có thể giảm gánh nặng cho bác sĩ lâm sàng và giúp ưu tiên cho các bệnh nhân
            </p>
            </div>
        </div>
          
        <div class="cnn">
            <div class="line"></div>
            <div class="mo-dau-cnn">
            <h3>
                mạng nơ-ron và mạng nơ-ron tích chập
            </h3>
            <p>
                Học sâu <i>(deep learning)</i> là một chi của ngành <a
                href="https://vi.wikipedia.org/wiki/H%E1%BB%8Dc_m%C3%A1y">học máy</a>
                (một lĩnh vực của <a href="https://vi.wikipedia.org/wiki/Tr%C3%AD_tu%E1%BB%87_nh%C3%A2n_t%E1%BA%A1o">trí tuệ nhân
                tạo</a>) dựa trên một tập hợp các thuật toán để cố gắng mô hình dữ liệu trừu tượng hóa ở mức cao bằng cách sử
                dụng nhiều lớp
                xử lý với cấu trúc phức tạp hoặc bằng cách khác bao gồm nhiều biến đổi phi tuyến
            </p>
            <div class="text-center">
                <img src="../static/img/tong-quan.png" alt="tong-quan" width="400px">
                <p class="name-img">Mối liên hệ giữa AI, Machine Learning và Deep Learning</p>
            </div>
            <p>
                Các nghiên cứu trong lĩnh vực học sâu cố gắng thực hiện tạo ra các mô hình để tìm hiểu các đại diện này từ dữ liệu
                không dán nhãn quy mô lớn.
                Một số đại diện được lấy cảm hứng bởi những tiến bộ trong khoa học thần kinh và được dựa trên các giải thích của
                mô hình xử lý và truyền thông tin trong một hệ thống thần kinh,
                chẳng hạn như mã hóa thần kinh để cố gắng để xác định các mối quan hệ giữa các kích thích khác nhau và các phản
                ứng liên quan đến thần kinh não.
                Có nhiều kiến trúc học sâu khác nhau nhưng phổ biến là mạng nơ-ron <i>(Neural Network)</i> và mạng nơ-ron tích
                chập <i>(Convolutional Neural Network)</i>
            </p>
            </div>
            
            <!-- Acor -->
            <div class="accordion md-accordion" id="accordionEx1" role="tablist" aria-multiselectable="true">
        
            <div class="card">
                <div class="card-header" role="tab" id="headingTwo1">
                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionEx1" href="#collapseTwo1"
                    aria-expanded="false" aria-controls="collapseTwo1">
                    <h5 class="mb-0">
                        Mạng nơ-ron 
                    </h5>
                    </a>
                </div>
                <div id="collapseTwo1" class="collapse" role="tabpanel" aria-labelledby="headingTwo1"
                    data-parent="#accordionEx1">
                    <div class="card-body">
                        Mạng nơ-ron là một hệ thống bao gồm nhiều phần tử xử lý đơn giản <i>(nơ-ron)</i>
                        tựa như nơ-ron thần kinh não người, hoạt động song song và được nối với nhau. Mỗi liên kết kèm theo một trọng số
                        nào đó, đặc trưng cho tính kích hoạt hoặc ức chế giữa các nơ-ron.
                        <br> Cấu trúc cơ bản của một Mạng nơ-ron bao gồm: một lớp vào <i>(input layer)</i>,
                        một lớp ra <i>(output layer)</i> và một hay nhiều lớp ẩn <i>(hidden layer)</i>. Mỗi lớp chứa nhiều nơ-ron, các
                        nơ-ron
                        giữa các lớp liên kết với nhau.
                        <div class="text-center">
                        <img src="../static/img/neural.jpeg" alt="neural" width="350px">
                        <p class="name-img">Cấu trúc của mạng nơ-ron</p>
                        </div>
                        Mỗi nơ-ron có cấu trúc như sau:
                        <div class="text-center">
                        <img src="../static/img/chi-tiet-neural.PNG" alt="perceptron" width="500px">
                        <p class="name-img">Sơ đồ tổng quát của một nơ-ron</p>
                        </div>
                        <div>
                        Chi tiết các thành phần:
                            <ul>
                                <li>Input: Mỗi input tương ứng là một thuộc tính của dữ liệu</li>
                                <li>Weights (trọng số liên kết): Mỗi liên kết được thể hiện bởi một trọng số liên kết.
                                Thông thường các trọng số này được khởi tạo ngẫu nhiên và được cập nhật liên tục trong quá trình huấn luyện
                                </li>
                                <li>Hàm tổng: Tính tổng trọng số của tất cả các input được đưa vào mỗi nơ-ron.
                                Hàm tổng của một nơ-ron đối với n input được tính theo công thức sau:
                                <img src="../static/img/cong-thuc-neural.PNG" alt="cong-thuc-neural" width="150px">
                                </li>
                                <li>Hàm kích hoạt: Hàm kích hoạt để tạo tín hiệu ra dựa trên giá trị hàm
                                tổng</li>
                                <li>Output: Là kết quả của mạng, đầu ra tương ứng khi nhận vào các đầu vào. </li>
                            </ul>
                        </div>
                        <div>
                            <b>Phương pháp học:</b>
                            <ul>
                                <li>Học có giám sát: Một thành phần không thể thiếu của phương pháp này là sự có
                                    mặt của một người thầy (ở bên ngoài hệ thống). Người thầy này có kiến thức về môi
                                    trường thể hiện qua một tập hợp các cặp đầu vào - đầu ra đã được biết trước. Hệ
                                    thống học (ở đây là mạng nơ – ron) sẽ phải tìm cách thay đổi các tham số bên trong
                                    của mình (các trọng số và các ngưỡng) để tạo nên một ánh xạ có khả năng ánh xạ
                                    các đầu vào thành các đầu ra mong muốn. Sự thay đổi này được tiến hành nhờ việc
                                    so sánh giữa đầu ra thực sự và đầu ra mong muốn
                                    <div class="text-center">
                                        <img src="../static/img/hoc-giam-sat.png" alt="hoc-giam-sat" width="300px">
                                        <p class="name-img">Sơ đồ khối học có giám sát</p>
                                    </div>
                                </li>
                                <li>Học không giám sát: Khác biệt với học có giám sát ở chỗ là đầu ra đúng tương ứng
                                    cho mỗi đầu vào là không biết trước. Trong học không có giám sát, một tập dữ liệu
                                    đầu vào được thu thập. Nó thường đối xử với các đối tượng đầu vào như là một tập
                                    các biến ngẫu nhiên. Sau đó, một mô hình mật độ kết hợp sẽ được xây dựng cho tập
                                    dữ liệu đó</li>
                                <li>Học tăng cường: Bạn có thể tưởng tượng một con chuột nhỏ chạy trong một mê
                                    cung. Nếu nó rẽ trái, nó sẽ nhận được một miếng phô mát, nhưng nếu nó rẽ phải, ở
                                    đó có một chiếc bẫy chuột. Theo thời gian, con chuột sẽ học được rằng nó cần phải
                                    rẽ trái. Mạng nơ – ron của nó sẽ phải quan sát môi trường xung quanh, thu thập thông
                                    tin và đưa ra các quyết định rẽ trái hoặc rẽ phải. Nếu những quan sát của nó không
                                    tốt, mạng nơ – ron sẽ phải điều chỉnh các trọng số của nó để đưa ra các quyết định
                                    khác trong thời gian tới. Phương pháp học tăng cường thường phổ biến trong các
                                    robot </li>
                            </ul>
                        </div>
                        <div>
                            <b>Huấn luyện mạng:</b>
                            <ul>
                                <li>Quá trình truyền thẳng</li>
                                <li>Quá trình lan truyền ngược
                                    <div class="text-center">
                                        <img src="../static/img/lan-truyen-nguoc.png" alt="lan-truyen-nguoc" width="400px">
                                        <p class="name-img">Quá trình lan truyền ngược</p>
                                    </div>
                                </li>
                            </ul>
                        </div>
                        
                    </div>
                </div>
            </div>
        
            <div class="card">
                <div class="card-header" role="tab" id="headingTwo2">
                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionEx1" href="#collapseTwo21"
                    aria-expanded="false" aria-controls="collapseTwo21">
                    <h5 class="mb-0">
                        Mạng nơ-ron tích chập 
                    </h5>
                    </a>
                </div>
        
                <div id="collapseTwo21" class="collapse" role="tabpanel" aria-labelledby="headingTwo21"
                    data-parent="#accordionEx1">
                    <div class="card-body">
                        Mạng nơ-ron tích chập là một trong những
                        mô hình học sâu phổ biến nhất hiện nay, có khả năng nhận dạng và phân loại hình ảnh với
                        độ chính xác cao.
                        <br>Kiến trúc một mạng nơ – ron tích chập thông thường bao gồm các lớp cơ bản sau:
                        Lớp tích chập (Convolutional), Lớp kích hoạt phi tuyến ReLU (Rectified Linear Unit), Lớp
                        lấy mẫu (Pooling) và Lớp liên kết đầy đủ (Fully – connected). Các lớp này được thay đổi
                        về số lượng và cách sắp xếp để tạo ra các mô hình huấn luyện phù hợp cho từng bài toán
                        khác nhau.
                        <div class="text-center">
                            <img src="../static/img/tong-quan-cnn.png" alt="tong-quan-cnn" width="600px">
                            <p class="name-img">Kiến trúc của mạng nơ-ron tích chập</p>
                        </div>
                        <b>- Lớp tích chập:</b> Đây là lớp quan trọng nhất của mạng CNN. Lớp tích chập lấy dữ liệu đầu vào, thực
                        hiện các phép chuyển đổi để tạo dữ liệu đầu vào cho các lớp kế tiếp (đầu ra của lớp này là
                        đầu vào của lớp khác), phép biến đổi được sử dụng là phép tính tích chập. Mỗi lớp tích chập
                        chứa một hay nhiều bộ lọc – bộ phát hiện đặc trưng (filter – feature detetor) cho phép phát
                        hiện và trích xuất các đặc trưng quan trọng của ảnh. Bước nhảy (stride) giúp xác định
                        khoảng dịch chuyển của bộ lọc khi tiến hành quét bộ lọc lên đầu vào.
                        <div class="text-center">
                            <img src="../static/img/tich-chap.gif" alt="tich-chap" width="650px">
                            <p class="name-img">Tích chập với 2 bộ lọc, 3 cột, 2 bước nhảy, lề bằng 1</p>
                        </div>
                        <b>- Lớp kích hoạt phi tuyến ReLU:</b> Lớp này được xây dựng với ý nghĩa đảm bảo tính phi tuyến của mô hình huấn
                        luyện
                        sau khi đã thực hiện một loạt các tính toán tuyến tính trong lớp tích chập
                        Trong số các hàm kích hoạt này hàm ReLU được lựa
                        chọn do cài đặt đơn giản, tốc độ xử lý nhanh mà vẫn đảm bảo được tính toán hiệu quả. Cụ
                        thể, phép tính toán của hàm ReLU là chuyển các giá trị âm thành giá trị 0.
                        <div class="text-center">
                            <img src="../static/img/relu.png" alt="relu" width="200px">
                            <p class="name-img">Hàm kích hoạt ReLU</p>
                        </div>
                        <b>- Lớp lấy mẫu:</b> Lớp lấy mẫu để giảm kích thước sẽ làm giảm số lượng tham số tính toán giúp rút ngắn thời gian huấn luyện và
                            tránh hiện tượng overfitting. Phương pháp lấy mẫu được sử dụng phổ biến nhất là max pooling. Phương pháp này
                            chỉ lấy giá trị lớn nhất tại vùng ảnh mà cửa sổ trượt đi qua. Khác với quá trình tính tích
                            chập quá trình này không có tham số. Tương tự như lớp tính tích chập ta phải chọn kích
                            thước cửa sổ (pooling size) và bước nhảy (stride).
                        <div class="text-center">
                            <img src="../static/img/pool.jpeg" alt="pool" width="300px">
                            <p class="name-img">Phương pháp lấy mẫu hàm max pool</p>
                        </div>
                        <b>- Lớp liên kết đầy đủ:</b> . Lớp liên kết đầy đủ được thiết kế
                        hoàn toàn tương tự như trong mạng nơ – ron truyền thống, nghĩa là mọi nơ – ron ở các lớp
                        trước được kết nối với mọi nơ – ron trong lớp liên kết đầy đủ. Giống như các lớp tích chập,
                        ReLU, lấy mẫu, … có thể có một hoặc nhiều lớp được liên kết đầy đủ tùy thuộc vào mức
                        độ trừu tượng của các đặc trưng. 
                        <div class="text-center">
                            <img src="../static/img/full-connect.png" alt="full-connect" width="500px">
                            <p class="name-img">Lớp liên kết đầy đủ</p>
                        </div>
                        <h4>Các kiểu mạng huấn luyện:</h4>
                        <!-- the -->
                        <div class="accordion md-accordion" id="accordionEx2" role="tablist" aria-multiselectable="true">
        
                            <div class="card">
                                <div class="card-header" role="tab" id="headingVgg">
                                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionEx2" href="#collapseVgg"
                                    aria-expanded="false" aria-controls="collapseVgg">
                                    <h5 class="mb-0">
                                        Mạng VGG (VGG-16 và VGG-19)
                                    </h5>
                                    </a>
                                </div>
                                <div id="collapseVgg" class="collapse" role="tabpanel" aria-labelledby="headingVgg"
                                    data-parent="#accordionEx2">
                                    <div class="card-body">
                                        Kiến trúc mạng VGG đã được K. Simonyan và A. Zisserman đến từ đại học
                                        Oxford giới thiệu trong bài báo của họ “Very Deep Convolutional Networks for LargeScale Image Recognition”, năm 2014. Mạng đạt được độ chính xác 92,7 % đối với bộ dữ
                                        liệu ImageNet. Đây là bộ dữ liệu với hơn 14 triệu ảnh và có hơn 1000 lớp
                                        <div class="text-center">
                                            <img src="../static/img/vggnet.jpg" alt="vgg" width="400px">
                                            <p class="name-img">Kiến trúc mạng VGG</p>
                                        </div>
                                        Mạng này được đặc trưng bởi sự đơn giản của nó, chỉ sử dụng các lớp chập với bộ
                                        lọc 3x3 xếp chồng lên nhau theo chiều sâu tăng dần. Giảm kích thước khối được xử lý bằng
                                        sử dụng max pooling. Hai lớp fully-connected, mỗi lớp có 4.096 nút được theo sau bởi một
                                        bộ phân loại softmax (ở trên).
                                        “16” và “19” có nghĩa là số lượng các lớp trọng số ở trong mạng. Cấu trúc của
                                        VGG16 bao gồm 16 lớp: 13 lớp Conv (2 lớp conv-conv, 3 lớp conv-conv-conv) đều có
                                        kernel 3x3, sau mỗi lớp conv là maxpooling để lấy mẫu xuống 0.5, và 3 lớp fully-connected.
                                        VGG19 tương tự như VGG16 nhưng có thêm 3 lớp tích chập ở 3 lớp conv cuối (thành 4
                                        conv xếp chồng với nhau)
                                        <div class="text-center">
                                            <img src="../static/img/vgg-16-architecture.png" alt="vgg-16-architecture" width="400px">
                                            <p class="name-img">Cấu trúc mạng VGG</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
        
                            <div class="card">
                                <div class="card-header" role="tab" id="headingGoogle">
                                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionEx2" href="#collapseGoogle"
                                    aria-expanded="false" aria-controls="collapseGoogle">
                                    <h5 class="mb-0">
                                        GoogleNet
                                    </h5>
                                    </a>
                                </div>
                                <div id="collapseGoogle" class="collapse" role="tabpanel" aria-labelledby="headingGoogle"
                                    data-parent="#accordionEx2">
                                    <div class="card-body">
                                        Năm 2014, google publish một mạng neural do nhóm research của họ phát triển có tên là googleNet. Nó performance tốt hơn VGG, googleNet 6.7% error rate trong khi VGG là 7.3%.
                                        Ý tưởng chính là họ tạo ra một module mới có tên là inception giúp mạng traning sâu và nhanh hơn, chỉ có 5m tham số so với alexnet là 60m nhanh hơn gấp 12 lần.
                                    <br> Inception module là một mạng CNN giúp training wider(thay vì thêm nhiều layer hơn vì rất dễ xảy ra overfitting + tăng parameter người ta nghĩ ra tăng deeper ở mỗi tầng layer) so với mạng CNN bình thường.
                                        Mỗi layer trong CNN truyền thống sẽ extract các thông tin khác nhau. Output của 5x5 conv kernel sẽ khác với 3x3 kernel.
                                        Vậy để lấy những thông tin cần thiết cho bài toán của chúng ta thì nên dùng kernel size như thế nào ? Tại sao chúng sử dụng tất cả ta và sau đó để model tự chọn. 
                                        Đó chính là ý tưởng của Inception module, nó tính toán các kernel size khác nhau từ một input sau đó concatenate nó lại thành output.
                                        <div class="text-center">
                                            <img src="../static/img/inception.jpg" alt="inception" width="450px">
                                            <p class="name-img">Cấu trúc mạng Inception</p>
                                        </div>
                                        Trong inception người ta dùng conv kernel 1x1 với 2 mục đích là giảm tham số tính toán và dimensionality reduction . Dimensionality reduction có thể hiểu làm giảm depth của input (vd iput 28x28x100 qua kernel 1x1 với filter = 10 sẽ giảm depth về còn 28x28x10). 
                                        Giảm chi phí tính toán có thể hiểu qua ví dụ sau:
                                        <ul>
                                            <li>Input shape 28x28x192 qua kernel 5x5 với 32 thì ouput là 28x28x32(padding same) thì tham số tính toán là (5x5x192)*(28x28x32)=120 million</li>
                                            <li>Input shape 28x28x192 qua kernel 1x1x192 filter = 16 , output = 28x28x16 tiếp tục với kernel 5x5x32 filter = 16 đươch output = 28x28x32. Tổng tham số tính toán : (28x28x16)192 + (28x28x32)(5x5x16) = 2.4 + 10 = 12.4 million.
                                                Ta thấy với cùng output là 28x28x32 thì nếu dùng kernel 5x5x192 với 32 filter thì sẽ có tham số gấp 10 lần so với sử dụng kernel 1x1x192 sau đó dùng tiếp 1 kernel 5x5x16 với filter 32</li>
                                        </ul>
                                        <div class="text-center">
                                            <img src="../static/img/google-net.jpg" alt="google-net" width="650px">
                                            <p class="name-img">Cấu trúc mạng GoogleNet</p>
                                        </div>
                                        GoogleNet gồm 22 lớp, khởi đầu vẫn là những lớp tích chập đơn giản, tiếp theo là những
                                        khối của mô – đun inception với max pooling theo sau mỗi khối. Một số đặc điểm chính:
                                        <ul>
                                            <li>Sử dụng 9 mô – đun Inception trên toàn bộ kiến trúc. Làm mô hình sâu hơn rất nhiều.</li>
                                            <li>Không sử dụng lớp fully connected mà thay vào đó là average pooling từ kích thước
                                                7x7x1024 thành 1x1x1024 giảm thiểu được rất nhiều số lượng tham số.</li>
                                            <li>Ít hơn 12 lần số lượng tham số so với Alexnet.</li>
                                            <li>Các Loss phụ (Auxiliary Loss) được thêm vào total loss (weight =0.3). Nhưng được
                                                loại bỏ khi test.</li>
                                        </ul>
                                        <!-- e -->
                                    </div>
                                </div>
                            </div>
        
                            <div class="card">
                                <div class="card-header" role="tab" id="headingResNet">
                                    <a class="collapsed" data-toggle="collapse" data-parent="#accordionEx2" href="#collapseResNet"
                                    aria-expanded="false" aria-controls="collapseResNet">
                                    <h5 class="mb-0">
                                        ResNet
                                    </h5>
                                    </a>
                                </div>
                                <div id="collapseResNet" class="collapse" role="tabpanel" aria-labelledby="headingResNet"
                                    data-parent="#accordionEx2">
                                    <div class="card-body">
                                        ResNet được phát triển bởi microsoft năm 2015 với bài báo “Deep residual
                                        learning for image recognition”. ResNet đã chiến thắng cuộc thi ImageNet ILSVRC
                                        competition 2015 với error rate 3.57%, ResNet có cấu trúc gần giống VGG với nhiều lớp
                                        xếp chồng lên nhau làm cho mô hình sâu hơn. Không giống VGG, ResNet có chiều sâu sâu
                                        hơn như 34, 55, 101 và 151. Resnet giải quyết được vấn đề của deep learning truyền thống,
                                        nó có thể dễ dàng huấn luyện mô hình với hàng trăm lớp. Để hiểu ResNet chúng ta cần hiểu
                                        vấn đề khi xếp chồng nhiều lớp khi huấn luyện, vấn đề đầu tiên khi tăng mô hình sâu hơn
                                        gradient sẽ bị vanishing/explodes. Vấn đề này có thể giải quyết bằng cách thêm Batch
                                        Normalization nó giúp chuẩn hóa đầu ra giúp các hệ số trở nên cân bằng hơn không quá
                                        nhỏ hoặc quá lớn nên sẽ giúp mô hình dễ hội tụ hơn. Vấn đề thứ 2 là suy giảm (degradation),
                                        Khi độ chính xác của mô hình bắt đầu bão hòa (saturated) thậm chí là giảm. Như hình 2.17
                                        bên dưới khi xếp chồng nhiều lớp hơn thì training error lại cao hơn ít lớp, như vậy vấn đề
                                        không phải là do overfitting. Vấn đề này là do mô hình không dễ huấn luyện khó học hơn,
                                        thử tượng tượng đang huấn luyện một mô hình đơn giản, sau đó chúng ta thêm nhiều lớp,
                                        các lớp sau khi thêm vào sẽ không học thêm được gì cả (identity mapping) nên độ chính
                                        xác sẽ tương tự như mô hình ban đầu mà không tăng. Resnet được ra đời để giải quyết vấn
                                        đề degradation này
                                        <div class="text-center">
                                        <img src="../static/img/so-sanh-resnet.png" alt="so-sanh-resnet" width="600px">
                                        <p class="name-img">Tăng độ sâu mạng dẫn đến hiệu suất kém hơn</p>
                                        </div>
                                        ResNet có kiến trúc gồm nhiều residual block, cứ sau hai lớp ta cộng đầu vào với
                                        đầu ra, ta thu được F(x) sau đó thêm x vào H(x) = F(x) + x. Model sẽ dễ học hơn khi chúng
                                        ta thêm đặc trưng từ lớp trước vào.
                                        <div class="text-center">
                                        <img src="../static/img/resnet-cau-truc.png" alt="resnet" width="400px">
                                        <p class="name-img">Một khối ResNet</p>
                                        </div>
                                        Việc xếp chồng các lớp không làm giảm hiệu suất mạng, bởi vì chúng ta có thể đơn giản xếp chồng ánh xạ nhận dạng
                                        lên mạng hiện tại và kiến trúc kết quả sẽ thực hiện tương tự. Điều này chỉ ra rằng mô hình sâu hơn không được tạo ra 
                                        lỗi đào tạo cao hơn so với các đối tác nông hơn. Họ đưa ra giả thuyết rằng việc để các lớp xếp chồng lên nhau phù hợp 
                                        với ánh xạ dư sẽ dễ hơn là để chúng phù hợp trực tiếp với ánh xạ lót mong muốn. 
                                        Và khối dư ở trên rõ ràng cho phép nó làm chính xác điều đó
                                        <div class="text-center">
                                            <img src="../static/img/resnets.jpg" alt="resnet" width="800px">
                                            <p class="name-img">Cấu trúc ResNet</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
        
                        </div>
        
                        <!-- athe -->
                    </div>
                </div>
        
            </div>
                
            </div>
            
        </div>
                
        <div class="dectecting">
            <div class="line" style="margin-top: 10px;"></div>
            <h3>hệ thống phát hiện</h3>
            <div class="row">
                <div class="col-sm-6">
                    <ul>
                        <li>Bước 1: Kích vào nút <b>"Chọn"</b>  được lựa chọn hình ảnh để phát hiện.</li>
                        <li>Bước 2: Kích đúp chuột trái vào hình ảnh lựa chọn. Hình ảnh sẽ xuất hiện ngoài giao diện.
                            Nếu muốn thay đổi hình ảnh làm lại "Bước 1".
                        </li>
                        <li>Bước 3: Kích vào nút <b>"Dự đoán"</b> để phát hiện và chờ đợi trong giây lát kết quả sẽ trả về</li>
                        <li>Bước 4: Nếu kết quả trả về: <b>"Ký Sinh Trùng"</b> thì đã bị nhiễm bệnh sốt rét
                         và <b>"Không Bị Nhiễm Bệnh"</b> thì không bị bệnh sốt rét </li>
                    </ul>
                </div>
                <div class="col-sm-6">
                    <div id="content">
                        
                        <div>
                            <form id="upload-file" method="post" enctype="multipart/form-data">
                                <label for="imageUpload" class="upload-label">
                                    Chọn
                                </label>
                                <input type="file" name="file" id="imageUpload" accept=".png, .jpg, .jpeg">
                            </form>
            
                            <div class="image-section" style="display:none;">
                                <div class="img-preview">
                                    <div id="imagePreview">
                                    </div>
                                </div>
                                <div>
                                    <button type="button" class="btn btn-primary btn-lg " id="btn-predict">Dự Đoán!</button>
                                </div>
                            </div>
            
                            <div class="loader" style="display:none;"></div>
            
                            <h3 id="result">
                                <span> </span>
                            </h3>
            
                        </div>
                    </div>
                </div>
            </div>
        
        </div>
    </div>


    <footer class="text-center" style="margin-top: 20px;">
        <p>2019</p>
        <p>Sinh viên thực hiện: Bùi Xuân Quý</p>
        <p>Giáo viên hướng dẫn: Phan Trần Đăng Khoa</p>
    </footer>

    <script src="../static/js/jquery-3.4.1.min.js"></script>
    <script src="../static/js/popper.min.js"></script>
    <script src="../static/js/bootstrap.min.js"></script>
    <script src="../static/js/jquery.bxslider.min.js"></script>
    <script src="../static/js/jquery-ui.min.js"></script>

    <script src="../static/js/indexs.js"></script>
</body>


</html>

